# Создание телеграмм бота для мотиноринга времени, проведенного за определенной деятельностью

Данная работа выполнена студентами 3 курса Программной инженерии в рамках курса "Конструирование ПО" 
```
Садофьева Анастасия Сергеевна 5130904/30106
Бредюк Ростислав Константинович 5130904/30106
Ивойловская Юлия Романовна 5130904/30106
```

#### Определение проблемы:

Пользователям сложно объективно оценивать, сколько времени они тратят на важные для них виды деятельности. Ручной подсчёт времени неудобен и часто неточен, что приводит к неэффективному планированию своего времени, а также отслеживаю результата.

#### Выработка требований:

   1. Как пользователь, я хочу видеть свою статистику и анализировать прогресс, чтобы понимать, сколько времени я трачу на свои цели. Я хочу иметь возможность запросить отчёт за выбранный период по одной или всем активностям.
   2. Как пользователь, я хочу легко начать отслеживание активности, чтобы не отвлекаться на сложные настройки. Для этого я хочу нажать кнопку с названием заранее созданной деятельности, чтобы таймер запустился. Когда я закончу, я хочу отправить команду нажать кнопку "Завершить", чтобы остановить отсчёт и автоматически сохранить сессию.

Количество пользователей в сутки: 10 000 пользователей
Период хранения информации: Вся информация о пользователи будет хранится по умолчанию в течении 5 лет. 

# Проект: Telegram-бот для мониторинга времени, проведённого за деятельностью


#### 1. Краткое описание проблемы и цели
   Проблема: пользователям трудно объективно отслеживать время на важные активности; ручной учёт неудобен и неточен.
   Цель: предоставить простой Telegram-интерфейс для запуска/остановки таймера по заранее созданным активностям, хранить сессии, давать отчёты и аналитику за выбранный период.
   Требования пользователя (ключевые):
     - Запуск трекинга одним нажатием кнопки;
     - Остановка — кнопкой «Завершить» (с автоматическим сохранением сессии);
     - Просмотр статистики/отчёта за период по одной/всем активностям;
     - Хранение данных 5 лет.


#### 2. Входные числа и допущения
   - Пользователей в сутки: 10 000.
   - Среднее число сессий на активного пользователя в сутки: 5.
   - Среднее число взаимодействий (команд/запросов) на пользователя в сутки: 10.
   - Средний размер записи сессии: 1 KB (консервативно 2 KB с индексами/логами).
   - Срок хранения: 5 лет.
   - Требуемая доступность: 99.9%, p95 latency ≤ 500 ms.

#### 3. Оценка нагрузки и объёмов данных
   Операции в день:
      - Сессии (writes): 50 000/день.
      - Прочие запросы (reads): ~80 000/день.
      - Итого: ~130 000/день.
   Среднее RPS: 1.5, Пиковое: ~22 (×10 рост → ~217).
   Хранилище: ~365 GB за 5 лет (с запасом), рекомендуется ≥ 1 TB SSD.


#### 4. Высокоуровневая архитектура
   Компоненты:
      1. Telegram Bot (Webhook receiver)
      2. Application Layer (stateless)
      3. PostgreSQL (Primary + Replicas)
      4. Redis (кэш/lock)
      5. Message Broker (RabbitMQ/Kafka)
      6. Background Workers
      7. Object Storage (S3)
      8. Monitoring & Logging
      9. CI/CD + Secret storage


#### 5. Telegram-специфика
   - Webhook предпочтительнее (низкая задержка).
   - Idempotency: проверка update_id или (user_id, message_id).
   - Обрабатывать callback_query и message.
   - Payload минимален.


#### 6. Поведение бота (state machine)
   Состояния: idle, tracking, paused.
   - Один активный трекер на пользователя.
   - Start → create session, lock в Redis.
   - End → save finished_at, duration, release lock.


#### 7. API (внутренние контракты)
   Примеры:
      - POST /sessions — создать сессию.
      - POST /sessions/{id}/end — завершить.
      - GET /users/{id}/stats — статистика.
      - POST /users/{id}/export — экспорт.


#### 8. БД схема
   Основные таблицы:
   - users (id, telegram_id, username, ...)
   - activities (id, user_id, name, ...)
   - sessions (id, user_id, activity_id, started_at, finished_at, duration)
   - session_events_log (id, session_id, event_type, payload)
   Индексы: по user_id и started_at/finished_at.


#### 9. Кэширование и очереди
   - Redis: lock + кэш агрегатов.
   - Message broker: событие session.finished → worker обновляет агрегаты.
   - Aggregated table: user_activity_aggregates.


#### 10. Нефункциональные требования
   - Время отклика ≤ 500 ms p95.
   - Доступность 99.9%.
   - Масштабируемость до ×10 нагрузки.
   - Архивирование старых данных (S3 Glacier).


#### 11. Масштабирование
   MVP: 2–3 pod’а, Postgres + replica, Redis single, RabbitMQ single.
   Рост: autoscale, Redis cluster, read replicas.
   Рост ×10: partitioning, Kafka, multi-region.


#### 12. Резервное копирование
   - DB: WAL archiving + full backup.
   - Redis: RDB + AOF.
   - DR план: RTO ≤ 1 час, RPO ≤ 1 час.


#### 13. Мониторинг
   Метрики: RPS, latency, error rate, DB lag, Redis hit/miss.
   Логи: централизованные, trace (Jaeger).
   Алерты: p95 > 500 ms, error_rate >1%, lag >5s.


#### 14. Безопасность
   - Секреты в Vault/KMS.
   - Минимизировать ПДн.
   - Право на удаление данных.
   - Rate limiting на webhook.


#### 15. Runbook
   - Webhook fail → fallback на polling.
   - Ошибки записи → проверить Redis/DB.
   - Backlog в очереди → добавить воркеры.


#### 16. UI/UX
   Главное меню: [ Начать], [Завершить], [Статистика], [ Настройки].
   Примеры сообщений:
   - «Сессия начата»
   - «Завершена — 32 мин. Всего сегодня: 2 ч 10 мин.»


#### 17. Инфраструктура
   App: 2 реплики, 0.5–1 vCPU, 1 GB RAM.
   DB: Postgres 4 vCPU, 16 GB RAM, SSD 1 TB.
   Redis: 2–3 ноды HA.
   Queue: RabbitMQ/Kafka.
   Storage: S3.
   CDN/proxy: Cloudflare.


#### 18. Заключение
   Архитектура подходит для 10k пользователей/сутки, масштабируется ×10.
   Ключ: простота UX, атомарные операции, асинхронные агрегации, резервирование хранения.
