Разработка архитектуры и детальное проектирование
Проект: Telegram-бот для мониторинга времени, проведённого за деятельностью
Авторы: Садофьева А.С., Бредюк Р.К., Ивойловская Ю.Р.
(3 курс, «Конструирование ПО»)

1. Краткое описание проблемы и цели
Проблема: пользователям трудно объективно отслеживать время на важные активности; ручной учёт неудобен и неточен.
Цель: предоставить простой Telegram-интерфейс для запуска/остановки таймера по активностям, хранить сессии, давать отчёты и аналитику.
Требования пользователя:
- Запуск трекинга одним нажатием кнопки;
- Остановка — кнопкой «Завершить» (с автоматическим сохранением сессии);
- Просмотр статистики/отчёта за период по одной/всем активностям;
- Хранение данных локально на ноутбуке.
2. Входные числа и допущения
- Пользователей в сутки: ~10 000 (планируемое количество для будущего переноса на сервер);
- Среднее число сессий на активного пользователя: 5;
- Среднее число взаимодействий на пользователя: 10;
- Размер записи сессии: ~1 KB;
- Срок хранения: зависит от объёма диска на ноутбуке;
- Доступность: проверка через консоль/логи.
3. Оценка нагрузки и объёмов данных
- Сессии (writes): ~50 000/день;
- Прочие запросы (reads): ~80 000/день;
- Нагрузка легко обрабатывается локальной PostgreSQL.
4. Высокоуровневая архитектура
Компоненты:
1. Telegram Bot — Python-скрипт с long polling;
2. Application Layer — логика запуска/остановки сессий, подсчёт времени, генерация отчётов;
3. PostgreSQL — локальная база данных с таблицами: users, activities, sessions;
4. Логи / файлы — для отладки и ручного сохранения при необходимости.
Примечание: Redis, очереди, фоновые воркеры и вебхуки не используются.
5. Telegram-специфика
- Используется long polling;
- Обработка команд и callback_query напрямую;
- Payload минимален.
6. Поведение бота (state machine)
- Состояния: idle, tracking;
- Один активный трекер на пользователя;
- Start → создаётся запись с started_at;
- End → обновляется finished_at.
7. Внутренние функции / API
- start_session(user_id, activity) — создаёт запись;
- end_session(user_id, activity) — завершает запись, добавляет finished_at;
- get_stats(user_id, period) — подсчитывает суммарное время.
8. База данных
Таблица sessions:
- id — уникальный идентификатор (PRIMARY KEY);
- user_id — идентификатор пользователя;
- activity — название активности;
- started_at — дата и время начала;
- finished_at — дата и время конца (NULL, если сессия ещё идёт);
Примечание: duration можно считать через finished_at - started_at.
9. Хранение данных
- Все данные сразу пишутся в PostgreSQL;
- Идентификация по user_id;
- Кэширование, Redis и очереди не используются.
10. Нефункциональные требования
- Простота использования: команды Начать, Завершить, Статистика;
- Быстрое выполнение операций (запись и чтение из локальной БД).
11. Масштабирование
- Не требуется;
- Все запросы обрабатываются одной локальной базой;
- Отчёты формируются простыми SQL-запросами.
12. Резервное копирование
- На текущем этапе не требуется;
- При желании можно вручную сохранить базу через клиент PostgreSQL.
13. Мониторинг
- Отдельного мониторинга нет;
- Проверка работы через вывод сообщений в консоль или текстовый файл.
14. Безопасность
- Данные хранятся локально на ноутбуке;
- Шифрование и SSL не используются;
- Доступ к базе есть только у владельца.
15. Runbook
- Если бот не отвечает — проверить, запущен ли скрипт;
- Если сессия не сохранилась — проверить работу PostgreSQL;
- При ошибках в коде — просмотреть консоль и перезапустить бота.
16. UI/UX
- Главное меню: [Начать], [Завершить], [Статистика], [Настройки];
- Примеры сообщений:
  - «Сессия начата»;
  - «Завершена — 32 мин. Всего сегодня: 2 ч 10 мин.»
17. Инфраструктура
MVP (локально):
- Бот и БД запускаются на ноутбуке;
- PostgreSQL: несколько гигабайт памяти, SSD/fast storage;
- Telegram Bot: Python-скрипт с long polling.
Будущее (сервер):
- Возможен перенос на арендованный сервер;
- Настройка вебхуков, SSL, масштабирование, мониторинг.
18. Заключение
- Архитектура полностью подходит для локального MVP на ноутбуке;
- Простота UX и минимальная структура базы позволяют быстро запускать проект;
- Код подготовлен с учётом будущего переноса на сервер при необходимости.

